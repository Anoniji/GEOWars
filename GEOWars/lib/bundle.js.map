{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/GEOWars.js","webpack:///./lib/game_engine/collider.js","webpack:///./lib/game_engine/color.js","webpack:///./lib/game_engine/game_engine.js","webpack:///./lib/game_engine/game_object.js","webpack:///./lib/game_engine/line_sprite.js","webpack:///./lib/game_engine/physics_component.js","webpack:///./lib/game_engine/sound.js","webpack:///./lib/game_engine/transform.js","webpack:///./lib/game_engine/util.js","webpack:///./lib/game_objects/Bullet/bullet.js","webpack:///./lib/game_objects/Bullet/bullet_sprite.js","webpack:///./lib/game_objects/enemies/Arrow/arrow.js","webpack:///./lib/game_objects/enemies/Arrow/arrow_sprite.js","webpack:///./lib/game_objects/enemies/BoxBox/boxbox.js","webpack:///./lib/game_objects/enemies/BoxBox/boxbox_sprite.js","webpack:///./lib/game_objects/enemies/Grunt/grunt.js","webpack:///./lib/game_objects/enemies/Grunt/grunt_sprite.js","webpack:///./lib/game_objects/enemies/Pinwheel/pinwheel.js","webpack:///./lib/game_objects/enemies/Pinwheel/pinwheel_sprite.js","webpack:///./lib/game_objects/enemies/Singularity/singularity.js","webpack:///./lib/game_objects/enemies/Singularity/singularity_sprite.js","webpack:///./lib/game_objects/enemies/Weaver/weaver.js","webpack:///./lib/game_objects/enemies/Weaver/weaver_sprite.js","webpack:///./lib/game_objects/particles/Particle/particle.js","webpack:///./lib/game_objects/particles/Particle/particle_sprite.js","webpack:///./lib/game_objects/particles/Singularity_Particle/singulairty_particle_sprite.js","webpack:///./lib/game_objects/particles/Singularity_Particle/singularity_particle.js","webpack:///./lib/game_objects/particles/bullet_wall_explosion.js","webpack:///./lib/game_objects/particles/enemy_spawn.js","webpack:///./lib/game_objects/particles/particle_explosion.js","webpack:///./lib/game_objects/particles/singularity_particles.js","webpack:///./lib/game_objects/ship/ship.js","webpack:///./lib/game_objects/ship/ship_sprite.js","webpack:///./lib/game_script.js","webpack:///./lib/game_view.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACZD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,G;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,K;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO;AAC/C,KAAK;AACL,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO;AACzD,KAAK;AACL,oBAAoB,OAAO,GAAG,OAAO,IAAI,OAAO;AAChD,KAAK;AACL,qBAAqB,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AAC/D;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qE;;;;;;;;;;;ACxOA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,O;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,2B;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;;;AAIH;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA,0C;;;;;;;;;;;AChEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B,0BAA0B;AAC1B,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA,6B;;;;;;;;;;;ACrCA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,6BAA6B;AAC7B,yBAAyB;AACzB,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA,8B;;;;;;;;;;;ACxEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA,0C;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB,yBAAyB;AACzB,2BAA2B;AAC3B;AACA;AACA;;;;;AAKA;;AAEA,6B;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA,0B;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,oBAAoB;;AAEpB;AACA;AACA;;;;;AAKA;;AAEA,gC;;;;;;;;;;;ACzEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0C;;;;;;;;;;;ACnGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACzDA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,0C;;;;;;;;;;;AC9GA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,+BAA+B;AAC/B,8BAA8B;AAC9B,6BAA6B;AAC7B,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;AClEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0B;;;;;;;;;;;ACzDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;ACnCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,2C;;;;;;;;;;;ACpCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qC;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4B;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,mC;;;;;;;;;;;AC9CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,sC;;;;;;;;;;;ACnFA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,O;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACrMA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,K;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;;AClSA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;;AAER;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;;AAER;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA,qCAAqC;AACrC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,sCAAsC;AACtC,mEAAmE;AACnE,0CAA0C;AAC1C;AACA;;;AAGA;AACA;AACA,oCAAoC;AACpC,iEAAiE;AACjE,wCAAwC;;AAExC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/GEOWars.js\");\n","const GameScript = require(\"./game_script\");\nconst GameView = require(\"./game_view\");\nconst GameEngine = require(\"./game_engine/game_engine\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = GameScript.DIM_X;\n  canvasEl.height = GameScript.DIM_Y;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  const gameEngine = new GameEngine(ctx);\n  new GameView(gameEngine, ctx, canvasEl).start();\n});\n\n","// engine takes in collider with gameobject type as string\n// this way subscriptions can be done via string names\n// enemy is subscribed to bullets..\n// each enemy will check every bullet\n// convert gameobject type to string\n// colliders can be added without subscriptions\n// subscriptions are an array of strings stored with the collider\n\n// collider: object absolute transform\n// collider { gameObject gameObject, \"subscriptions\" [\"name\", \"name\"] }\n// colliders {\"BoxBox\" [collider, collider]}\n\nconst Util = require(\"./util\")\n\nclass Collider {\n  constructor(type, gameObject, radius = 5, subscriptions, subscribedColliderTypes) {\n    this.objectType = gameObject.constructor.name\n    this.type = type\n    this.subscriptions = subscriptions\n    this.subscribedColliderTypes = subscribedColliderTypes\n    this.radius = radius\n    this.gameObject = gameObject\n  }\n  // wondering if collision should cascade up the parent objects\n  // nope not yet anyway\n\n  collisionCheck(otherCollider) {\n    const centerDist = Util.dist(this.gameObject.transform.absolutePosition(), otherCollider.gameObject.transform.absolutePosition());\n    if (centerDist < (this.radius + otherCollider.radius)){\n      this.gameObject.onCollision(otherCollider, this.type)\n    }\n  } \n}\n\nmodule.exports = Collider;\n\n// on\n\n// When you add new things that effect other things\n// like a new type of bullet, singularity effect, etc\n// you just have to add that functionality to the bullet\n// add the things it effects as things \n// the collider subscribes to\n// this way you don't have to edit every object type\n// that is effected\n\n// singularity has two colliders\n// outer one for gravity effects \n// inner one for actual hits\n// it's subscribed to everything\n// on collision it changes that object properties either \n// directly or with a object method... preferably","\nclass Color {\n  constructor(colorSpec){\n    this.colorType = Object.keys(colorSpec)[0]\n    this.creationErrorCheck(colorSpec)\n    this.extractColorInfo(colorSpec)\n  }\n\n  creationErrorCheck(colorSpec){\n    if (Object.keys(colorSpec).length !== 1) {\n      new Error(\"Color object accepts one color type\")\n    }\n    if (!Color.COLOR_TYPES.includes(this.colorType)) {\n      new Error(\"Color Object given unsupported color type\")\n    }\n  }\n\n  dup(){\n    let dupSpec = {}\n    if (this.colorType === \"rgb\") {\n      dupSpec[\"rgb\"]  = [this.r, this.g, this.b]\n    } else if (this.colorType === \"rgba\") {\n      dupSpec[\"rgba\"] = [this.r, this.g, this.b, this.a]\n    } else if (this.colorType === \"hsl\") {\n      dupSpec[\"hsl\"]  = [this.h, this.s, this.l]\n    } else if (this.colorType === \"hsla\") {\n      dupSpec[\"hsla\"] = [this.h, this.s, this.l, this.a]\n    }\n    let newColor = new Color(dupSpec)\n    return newColor\n  }\n\n  extractColorInfo(colorSpec){\n    if (this.colorType === \"rgb\"){\n      this.r = colorSpec[this.colorType][0]\n      this.g = colorSpec[this.colorType][1]\n      this.b = colorSpec[this.colorType][2]\n    } else if (this.colorType === \"rgba\"){\n      this.r = colorSpec[this.colorType][0]\n      this.g = colorSpec[this.colorType][1]\n      this.b = colorSpec[this.colorType][2]\n      this.a = colorSpec[this.colorType][3]\n    } else if (this.colorType === \"hsl\"){\n      this.h = colorSpec[this.colorType][0]\n      this.s = colorSpec[this.colorType][1]\n      this.l = colorSpec[this.colorType][2]\n    } else if (this.colorType === \"hsla\"){\n      this.h = colorSpec[this.colorType][0]\n      this.s = colorSpec[this.colorType][1]\n      this.l = colorSpec[this.colorType][2]\n      this.a = colorSpec[this.colorType][3]\n    } \n    colorSpec[this.colorType]\n  }\n\n  evaluateColor(){\n    if (this.colorType === \"rgb\"){\n      return `rbg(${this.r},${this.g},${this.b},)`\n    } else if (this.colorType === \"rgba\"){\n      return `rbg(${this.r},${this.g},${this.b},${this.a})`\n    } else if (this.colorType === \"hsl\"){\n      return `hsl(${this.h},${this.s}%,${this.l}%`\n    } else if (this.colorType === \"hsla\") {\n      return `hsla(${this.h}, ${this.s}%, ${this.l}%, ${this.a}`\n    }\n  }\n}\nColor.COLOR_TYPES = [\"rgb\", \"rgba\", \"hsl\", \"hsla\"]\n\nmodule.exports = Color;","const GameScript = require(\"../game_script\");\n// const GameObject = require(\"./game_boject\");\n// const LineRenderer = require(\"./line_renderer\");\n// const PhysicsComponent = require(\"./physics_component\")\n// const Sound = require(\"./sound\")\n// const Transform = require(\"./transform\")\n// const Util = require(\"./util\")\n\nclass GameEngine {\n  constructor(ctx) {\n    this.ctx = ctx\n    this.gameObjects = [];\n    this.physicsComponents = [];\n    this.lineSprites = [];\n    this.soundsToPlay = {};\n    this.colliders = {};\n    this.subscribers = [];\n    this.muted = true;\n    this.mouseListeners = [];\n    this.leftControlStickListeners = [];\n    this.gameScript = new GameScript(this);\n    this.toRemoveQueue = []\n    this.paused = false;\n  }\n\n  tick(delta) {\n    if(this.paused){\n      return\n    }\n    if(delta > 125){\n      delta = 125\n    }\n    this.checkCollisions()\n    this.movePhysicsComponents(delta)\n    this.updateGameObjects(delta)\n    this.clearCanvas()\n    this.renderLineSprites(this.ctx)\n    this.updateGameScript(delta)\n    this.playSounds()\n  }\n\n  pause(){\n    this.paused = true\n    this.gameScript.onPause()\n  }\n\n  unPause(){\n    this.paused = false\n    this.gameScript.onUnPause()\n  }\n\n  togglePause(){\n    this.paused ? this.unPause() : this.pause()\n  }\n\n  clearCanvas(){\n\n    this.ctx.clearRect(0, 0, this.gameScript.DIM_X, this.gameScript.DIM_Y);\n    this.ctx.fillStyle = this.gameScript.BG_COLOR;\n    this.ctx.fillRect(0, 0, this.gameScript.DIM_X, this.gameScript.DIM_Y);\n  }\n\n  addLeftControlStickListener(object){\n    this.leftControlStickListeners.push(object)\n  }\n\n  updateLeftControlStickListeners(unitVector){\n    this.leftControllStickListeners.forEach((listener) => {\n      listener.updateLeftControlStickInput(unitVector)\n    })\n  }\n\n  updateMousePos(mousePos){\n    this.mouseListeners.forEach((object) => {\n      object.updateMousePos(mousePos)\n    })\n  }\n\n  movePhysicsComponents(delta) {\n    this.physicsComponents.forEach((component) => {\n      component.move(delta)\n    })\n  }\n\n  addCollider(collider){\n    if (collider.subscriptions) {\n      this.subscribers.push(collider)\n    }\n    let colliders = this.colliders\n    // collider: object absolute transform\n    // collider {\"objectType\": \"Bullet\", \"type\": \"general\", \"subscriptions\": [\"BoxBox\", \"Arrow\"], \"subscribedColliderTypes\": [\"General\"]}\n    // colliders {\"Singularity\": {\"General\": [collider, collider], \"GravityWell\": [collider, collider]}}\n    if (!colliders[collider.objectType]) {\n      let collidersSameTypeAndObject = {}\n      collidersSameTypeAndObject[collider.type] = [collider]\n      colliders[collider.objectType] = collidersSameTypeAndObject\n    } else {\n      if (!colliders[collider.objectType][collider.type]){\n        colliders[collider.objectType][collider.type] = [collider]\n      } else {\n        colliders[collider.objectType][collider.type].push(collider)\n      }\n    }\n  }\n\n  // must be a way to only retrieve \n  // the data for subscribed colliders once\n\n  checkCollisions() {\n// colliders{\n// \"Arrow\": [collider, collider]\n// }\n\n// collider {\n//   \"objectType\": \"Bullet\",\n//   \"type\": \"general\",\n//   \"subscriptions\": [\"BoxBox\", \"Arrow\"],\n//   \"subscribedColliderTypes\": [\"general\"]\n// }\n    let subscribers = this.subscribers\n    let colliders = this.colliders\n    subscribers.forEach((subscriber) => {\n      subscriber.subscriptions.forEach((subscription) => {\n        colliders[subscription] = colliders[subscription] || {}\n        subscriber.subscribedColliderTypes.forEach((colliderType) => {\n          colliders[subscription][colliderType] = colliders[subscription][colliderType] || []\n          colliders[subscription][colliderType].forEach((subscribedCollider) => {\n            subscriber.collisionCheck(subscribedCollider)\n          })\n        })\n      })\n    })\n  }\n\n  updateGameObjects(delta) {\n    \n    this.gameObjects.forEach((object) => {\n      object.update(delta)\n    })\n  }\n\n  toggleMute(){\n    this.muted = !this.muted\n  }\n\n  playSounds(){\n    Object.values(this.soundsToPlay).forEach((sound) => {\n      sound.play();\n    })\n    this.soundsToPlay = {};\n  }\n\n  renderLineSprites(ctx) {\n    \n    this.lineSprites.forEach((sprite) => {\n      sprite.draw(ctx)\n    })\n  }\n\n  addMouseListener(object){\n    this.mouseListeners.push(object)\n  }\n  \n\n  updateGameScript(delta) {\n    this.gameScript.update(delta)\n  }\n\n  addGameObject(object) {\n    this.gameObjects.push(object)\n  }\n\n  addPhysicsComponent(physicsComponent){\n    this.physicsComponents.push(physicsComponent)\n  }\n\n  addLineSprite(lineSprite) {\n    this.lineSprites.push(lineSprite)\n  }\n\n  queueSound(sound){\n    if (!this.muted){\n      this.soundsToPlay[sound.url] = sound\n    }\n  }\n\n  // remove(gameObject){\n  //   this.toRemoveQueue.push(gameObject)\n  // }\n\n  // emptyRemoveQueue(){\n  //   this.toRemoveQueue.forEach((gameObject) => {\n  //     this.removeAction(gameObject)\n  //   })\n  // }\n\n  remove(gameObject) {\n    if (gameObject.physicsComponent) {\n      this.physicsComponents.splice(this.physicsComponents.indexOf(gameObject.physicsComponent), 1)\n    }\n    if (gameObject.lineSprite){\n      this.lineSprites.splice(this.lineSprites.indexOf(gameObject.lineSprite), 1)\n    }\n    this.removeColliders(gameObject.colliders)\n\n    this.gameObjects.splice(this.gameObjects.indexOf(gameObject), 1);\n  }\n\n  removeColliders(colliders){\n    colliders.forEach((collider) => {\n\n      if (collider.subscriptions) {\n        this.subscribers.splice(this.subscribers.indexOf(collider), 1)\n      }\n\n      let objectAndColliderTypeList = this.colliders[collider.objectType][collider.type]\n      objectAndColliderTypeList.splice(objectAndColliderTypeList.indexOf(collider), 1)\n\n\n    })\n  }\n}\n\nmodule.exports = GameEngine;\n\n    // the idea:\n    // engine takes in collider with gameobject type as string\n    // this way subscriptions can be done via string names\n    // enemy is subscribed to bullets..\n    // each enemy will check every bullet\n    // convert gameobject type to string\n    // colliders can be added without subscriptions\n    // subscriptions are an array of strings stored with the collider","const Util = require(\"./util\");\nconst Sound = require(\"./sound\")\n\nconst Transform = require( \"./transform\")\nconst PhysicsComponent = require(\"./physics_component\")\nconst LineSprite = require(\"./line_sprite\")\nconst Collider = require(\"./collider\")\n\nclass GameObject {\n  constructor(engine) {\n    this.gameEngine = engine\n    this.gameEngine.addGameObject(this)\n    this.transform = new Transform()\n    this.childObjects = []\n    this.physicsComponent = null \n    this.lineSprite = null\n    this.parentObject = null\n    this.colliders = []\n  }\n\n  addPhysicsComponent() {\n    this.physicsComponent = new PhysicsComponent(this.transform)\n    this.gameEngine.addPhysicsComponent(this.physicsComponent)\n  }\n\n  addLineSprite(lineSprite) {\n    this.lineSprite = lineSprite\n    this.gameEngine.addLineSprite(this.lineSprite)\n  }\n\n  addMousePosListener(){\n    this.gameEngine.addMouseListener(this)\n  }\n\n\n  addLeftControlStickListener() {\n    this.gameEngine.addLeftControlStickListener(this)\n  }\n\n  updateLeftControlStickInput(direction){\n\n  }\n\n  updateMousePos(mousePos){\n\n  }\n\n  addCollider(type, gameObject, radius, subscriptionTypes, subscriptions){\n    // game engine checks every collider with it's subscription types\n    let newCollider = new Collider(type, gameObject, radius, subscriptionTypes, subscriptions)\n    this.colliders.push(newCollider)\n    this.gameEngine.addCollider(newCollider)\n  }\n\n  // store sound in instance\n  playSound(sound){\n    this.gameEngine.queueSound(sound)\n  }\n\n\n  // relative motion needs to be fixed... FOR ANOTHER TIME\n  addChildGameObject(obj, relative){\n    this.childObjects.push(obj)\n    if(relative){\n      obj.transform.parentTransform = this.transform\n    }\n    obj.parentObject = this\n  }\n\n  update() {\n    // overwritten by child class for update scripts\n  }\n\n  onCollision(collider, type) {\n    // overwritten by child class for handler\n  }\n\n  // remove is the issue\n  // i need a remove queue!!!\n  // ... I think\n  remove() {\n    this.childObjects.forEach((obj) => {\n      obj.remove()\n    })\n    if(this.parentObject){\n      this.parentObject.childObjects.splice(this.parentObject.childObjects.indexOf(this), 1)\n    }\n    this.gameEngine.remove(this);\n  }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nmodule.exports = GameObject;\n","class LineSprite {\n  constructor(transform) {\n    // this.drawFunction = draw\n    this.transform = transform \n  }\n\n  draw(ctx) {\n    pos = this.transform.absolutePosition()\n    angle = this.transform.abosluteAngle()\n    this.drawFunction(ctx, pos, angle)\n  }\n}\n\nmodule.exports = LineSprite;","const Util = require(\"./util\");\nconst Sound = require(\"./sound\")\n\nclass PhysicsComponent {\n  constructor(transform) {\n    this.transform = transform\n  }\n\n  move(timeDelta) {\n    // timeDelta is number of milliseconds since last move\n    // if the computer is busy the time delta will be larger\n    // in this case the PhysicsObject should move farther in this frame\n    // velocity of object is how far it should move in 1/60th of a second or something\n    const timeScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    this.transform.pos[0] += this.transform.vel[0] * timeScale + this.transform.acc[0] * (timeScale * timeScale) / 2;\n    this.transform.pos[1] += this.transform.vel[1] * timeScale + this.transform.acc[1] * (timeScale * timeScale) / 2;\n    this.transform.vel[0] += this.transform.acc[0] * timeScale;\n    this.transform.vel[1] += this.transform.acc[1] * timeScale;\n\n    this.transform.acc = [0, 0];\n\n  }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nmodule.exports = PhysicsComponent;\n","\nclass Sound {\n  constructor(url, volume = 1, muted = false){\n    this.url = url;\n    this.volume = volume;\n    this.muted = muted;\n  }\n\n  play() {\n    this.sound = new Audio(this.url);\n    this.sound.volume = this.volume;\n    this.sound.play();\n  }\n  toggleMute(){\n    this.muted ? this.unmute() : this.mute()\n  }\n\n  unmute(){\n    this.muted = false \n    this.sound.volume = this.volume\n  }\n\n  mute(){\n    this.muted = true\n    this.sound.volume = 0\n  }\n\n  pause(){\n    this.sound.pause()\n  }\n}\n\nmodule.exports = Sound;","const Util = require(\"./util\");\nclass Transform {\n  constructor(pos = [0,0], vel = [0,0], acc = [0,0], angle = 0, parentTransform = null){\n    this.parentTransform = parentTransform\n    this.angle = angle\n    this.pos = pos\n    this.vel = vel\n    this.acc = acc\n  }\n\n  // call up the tree of parent transforms until null\n  // performing the transformation each step for the absolute\n  absoluteAngle() {\n    if (this.parentTransform == null) {\n      return this.angle\n    } else {\n      return this.angleAdd(this.angle, this.parentTransform.absoluteAngle())\n    }\n  }\n\n  absolutePosition() {\n    let absPos = []\n    if (this.parentTransform == null){\n      absPos = this.pos\n      return absPos\n    } else { \n      return this.vectorAdd(this.pos, this.parentTransform.absolutePosition())\n    }\n  }\n\n  absoluteVelocity() {\n    let absVel = []\n    if (this.parentTransform == null) {\n      absVel = this.vel\n      return absVel\n    } else {\n      return this.vectorAdd(this.vel, this.parentTransform.absoluteVelocity())\n    }\n  }\n\n  absoluteAcceleration() {\n    let absAcc = []\n    if (this.parentTransform == null) {\n      absAcc = this.acc\n      return absAcc\n    } else {\n      return this.vectorAdd(this.acc, this.parentTransform.absoluteAcceleration())\n    }\n  }\n\n  vectorAdd(vector1, vector2) {\n    return [vector1[0] + vector1[0], vector1[1] + vector2[1]]\n  }\n\n  angleAdd(angle1, angle2) {\n\n    return (angle1 + angle2) % (2 * Math.PI)\n  }\n\n}\n\nmodule.exports = Transform;","\nconst Util = {\n  // Normalize the length of the vector to 1, maintaining direction.\n  dir(vec) {\n    const norm = Util.norm(vec);\n    return Util.scale(vec, 1 / norm);\n  },\n  vectorCartisian(angle,scale){\n\n    let vector = [];\n    vector = [scale * Math.cos(angle), scale * Math.sin(angle)]\n    return vector\n  },\n  // Find distance between two points.\n  dist(pos1, pos2) {\n    return Math.sqrt(\n      Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n    );\n  },\n  // Find the length of the vector.\n  norm(vec) {\n    return Util.dist([0, 0], vec);\n  },\n  // Return a randomly oriented vector with the given length.\n  randomVec(length) {\n    const deg = 2 * Math.PI * Math.random();\n    return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n  },\n  // Scale the length of a vector by the given amount.\n  scale(vec, m) {\n    return [vec[0] * m, vec[1] * m];\n  },\n\n  \n \n};\n\nmodule.exports = Util;\n","const GameObject = require(\"../../game_engine/game_object\");\nconst Sound = require(\"../../game_engine/sound\")\nconst BulletWallExplosion = require(\"../particles/bullet_wall_explosion\")\nconst BulletSprite = require(\"./bullet_sprite\")\nconst ParticleExplosion = require(\"../particles/particle_explosion\")\nclass Bullet extends GameObject {\n  constructor(engine, pos, vel, bulletNumber) {\n    super(engine);\n    this.ID = bulletNumber\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    this.transform.vel[0] = vel[0]\n    this.transform.vel[1] = vel[1]\n    this.length = 12;\n    this.radius = this.length / 4;\n    this.wrap = false\n    this.wallhit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 1)\n    this.addExplosionCollider()\n    this.addPhysicsComponent()\n    this.addLineSprite(new BulletSprite(this.transform))\n    this.exploded = false;\n  }\n\n  addExplosionCollider(){\n    let subscribers = [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\"]\n    this.addCollider(\"bulletHit\", this, this.radius, subscribers, [\"General\"])\n    this.addCollider(\"General\", this, 3)\n  }\n\n  update(deltaTime){\n    \n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition()) && !this.exploded) {\n      this.exploded = true\n      new BulletWallExplosion(this.gameEngine, this.transform.pos)\n\n      this.gameEngine.queueSound(this.wallhit)\n      this.remove();\n    }\n  }\n\n  onCollision(collider, type){\n    if (type === \"bulletHit\") {\n      let hitObjectTransform = collider.gameObject.transform\n      let pos = hitObjectTransform.absolutePosition() \n      let vel = hitObjectTransform.absoluteVelocity()\n      let explosion = new ParticleExplosion(this.gameEngine, pos, vel)\n      collider.gameObject.remove()\n    }\n  }\n  \n  // move(timeDelta) {\n\n    \n\n  // }\n    \n}\n\n\nBullet.RADIUS = 3;\nBullet.SPEED = 7;\n\nmodule.exports = Bullet;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../game_engine/line_sprite\")\n\nclass BulletSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.length = 12\n  }\n\n  draw(ctx) {\n\n    let l = this.length\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    \n    let w = this.length / 2;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = \"#FBFBC2\";\n    ctx.lineWidth = 1;\n\n    ctx.moveTo(-l / 4, l / 2); //1\n    ctx.lineTo(0, -l / 2); //2\n    ctx.lineTo(l / 4, l / 2); //3\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n\n  }\n}\nmodule.exports = BulletSprite","const GameObject = require(\"../../../game_engine/game_object\")\nconst Util = require(\"../../../game_engine/util\");\nconst Sound = require(\"../../../game_engine/sound\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst ArrowSprite = require(\"./arrow_sprite\")\n \nclass Arrow extends GameObject {\n  constructor(engine, pos, angle = Math.PI / 3) {\n    super(engine)\n    this.transform.pos = pos;\n    this.transform.angle = angle;\n    this.speed = 3;\n    this.transform.vel = Util.vectorCartisian(this.transform.angle, this.speed);\n    \n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_purple.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new ArrowSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.exists = false\n  }\n  \n  exist(){\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, 3)\n    // now it will move\n    this.addPhysicsComponent()\n    this.exists = true\n  }\n\n  update(delta) {\n      // ADD TO UPDATE FOR THE OBJECTS\n    let pos = this.transform.absolutePosition()\n    if (this.gameEngine.gameScript.isOutOfBounds(pos)) {\n      this.gameEngine.gameScript.redirect(this.transform)\n    }\n  }\n}\n\nmodule.exports = Arrow;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass ArrowSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let spawningScale = this.spawningScale || 1;\n    let shipLength = 8 * 2.2 * spawningScale;\n    let shipWidth = 6 * 2.2 * spawningScale;\n    let l = shipLength;\n    let w = shipWidth;\n    let movementDirection = Math.atan2(this.transform.vel[0], -this.transform.vel[1])\n\n    let r = 255;\n    let g = 255;\n    let b = 50;\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    // ctx.strokeStyle = \"#f2ff00\"; // look up rgb and put here\n    ctx.lineWidth = 2;\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor;\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 6 * blurFactor;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 4.5;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 3;\n    this.drawArrow(ctx, l, w);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawArrow(ctx, l, w);\n\n    ctx.restore();\n  }\n\n  drawArrow(ctx, l, w) {\n    ctx.beginPath();\n    ctx.moveTo(0, -l / 2); //1\n    ctx.lineTo(w / 2, l / 4); //2\n    ctx.lineTo(w / 6, l / 2); //3\n    ctx.lineTo(0, l / 4); //4\n    ctx.lineTo(-w / 6, l / 2); //5\n    ctx.lineTo(-w / 2, l / 4); //6\n    ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = ArrowSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Util = require(\"../../../game_engine/util\")\nconst Sound = require(\"../../../game_engine/sound\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst BoxBoxSprite = require(\"./boxbox_sprite\")\n\nclass BoxBox extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.transform.pos = pos\n    this.radius = 3\n    // this.addPhysicsComponent()\n    this.addLineSprite(new BoxBoxSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.playSound(this.spawnSound)\n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n \n  wallGraze(){\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  update(delta){\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition())) {\n      this.wallGraze() \n    }\n  }\n}\n\nmodule.exports = BoxBox;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass BoxBoxSprite extends LineSprite{\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n\n    let spawningScale = this.spawningScale || 1;\n    let pos = this.transform.absolutePosition()\n    let boxSize = 10 * spawningScale;\n\n    // ctx.strokeStyle = \"#F173BA\";\n\n    let r = 210;\n    let g = 75;\n    let b = 75;\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor;\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 6 * blurFactor;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 4.5;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 3;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.restore();\n  }\n\n  drawBox1(ctx, boxSize) {\n    let w = boxSize\n    let slideFactor = 1.125\n    ctx.beginPath();\n    ctx.moveTo(w  / 4, -w  / 4);\n    ctx.lineTo(w  / 4, (3 * w)  / 4);\n    ctx.lineTo((-3 * w ) / 4, (3 * w ) / 4);\n    ctx.lineTo((-3 * w ) / 4, -w  / 4)\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  drawBox2(ctx, boxSize) {\n    let w = boxSize\n    let slideFactor = 1.5\n    ctx.beginPath();\n    ctx.moveTo(-w  / 4, w  / 4);\n    ctx.lineTo(-w  / 4, (-3 * w ) / 4);\n    ctx.lineTo((3 * w ) / 4, (-3 * w ) / 4);\n    ctx.lineTo((3 * w ) / 4, w  / 4)\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n}\n\nmodule.exports = BoxBoxSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst GruntSprite = require(\"./grunt_sprite\")\n\nclass Grunt extends GameObject {\n  constructor(engine, pos, shipTransform) {\n    super(engine)\n    this.transform.pos = pos\n    this.exists = false;\n    this.stretchDirection = -1;\n    this.shipTransform = shipTransform\n    this.radius = 5;\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new GruntSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n  }\n\n  exist() {\n    this.exists = true;\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n\n  // ADDING MOVEMENT MECHANICS FOR GRUNT\n\n  chase(timeDelta) {\n    let speed = 1.5\n    let shipPos = this.shipTransform.absolutePosition();\n    let pos = this.transform.absolutePosition()\n    let dy = shipPos[1] - pos[1];\n    let dx = shipPos[0] - pos[0];\n\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let direction = Math.atan2(dy, dx);\n\n    pos[0] += speed * Math.cos(direction) * velocityScale\n    pos[1] += speed * Math.sin(direction) * velocityScale\n  }\n\n  update(timeDelta) {\n    if (this.exists) {\n      this.chase(timeDelta)\n      let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      let cycleSpeed = 0.01;\n      if (this.lineSprite.stretchScale_W < 0.7 || this.lineSprite.stretchScale_W > 1) {\n        this.stretchDirection *= -1\n      }\n\n      this.lineSprite.stretchScale_W = this.lineSprite.stretchScale_W + -this.stretchDirection * cycleSpeed * cycleSpeedScale;\n      this.lineSprite.stretchScale_L = this.lineSprite.stretchScale_L + this.stretchDirection * cycleSpeed * cycleSpeedScale;\n\n      if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition())) {\n        this.wallGraze()\n      }\n    }\n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  \n}\n\nmodule.exports = Grunt;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass GruntSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.stretchScale_L = 1\n    this.stretchScale_W = 0.7\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    \n    let spawningScale = this.spawningScale;\n    let shipLength = 10 * 2.2 * spawningScale * this.stretchScale_L;\n    let shipWidth = 10 * 2.2 * spawningScale * this.stretchScale_W;\n    let l = shipLength;\n    let w = shipWidth;\n\n    let r = 0;\n    let g = 57;\n    let b = 230;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n\n    let blurFactor = 0.5\n\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 6 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 4.5 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 3 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    \n    ctx.restore();\n  }\n\n  drawDiamond(ctx, l, w) {\n    ctx.beginPath();\n    ctx.moveTo(0, -l / 2); //1\n    ctx.lineTo(w / 2, 0); //2\n    ctx.lineTo(0, l / 2); //3\n    ctx.lineTo(-w / 2, -0); //4\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n\n}\n\nmodule.exports = GruntSprite;","const Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst PinwheelSprite = require(\"./pinwheel_sprite\")\n\nclass Pinwheel extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.rotation_speed = 0.05;\n    let speed = 1;\n    this.transform.pos = pos\n    this.transform.vel = Util.randomVec(speed);\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new PinwheelSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.radius = 5;\n  }\n  \n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n\n  update(deltaTime){\n    let rotationSpeedScale = deltaTime / NORMAL_FRAME_TIME_DELTA;\n    this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2)\n\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition())) {\n      this.gameEngine.gameScript.bounce(this.transform, this.radius) // HARD CODED\n    }\n  }\n\n}\n\n\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\nmodule.exports = Pinwheel;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass PinwheelSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    let spawningScale = this.spawningScale || 1\n    let pos = this.transform.absolutePosition()\n    let angle = this.transform.absoluteAngle()\n\n    let shipWidth = 12 * spawningScale\n    let s = shipWidth / 2\n\n    let r = 59;\n    let g = 10;\n    let b = 87;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(angle);\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 6 * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 4.5;\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 3;\n    this.drawPinwheel(ctx, s)\n    ctx.strokeStyle = 'rgb(200, 100, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawPinwheel(ctx, s)\n\n    // ctx.strokeStyle = \"#971adf\";\n    // ctx.lineWidth = 1.8;\n\n    ctx.restore();\n  }\n\n  drawPinwheel(ctx, s) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(-s, -s); //2\n    ctx.lineTo(0, -s); //3\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(s, -s); //4\n    ctx.lineTo(s, 0); //5\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(s, s); //6\n    ctx.lineTo(0, s); //7\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(-s, s); //8\n    ctx.lineTo(-s, 0); //9\n    // ctx.lineTo(); //1\n\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n\n}\n\nmodule.exports = PinwheelSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst SingularitySprite = require(\"./singularity_sprite\")\nconst SingularityParticles = require(\"../../particles/singularity_particles\")\nclass Singularity extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.transform.pos = pos;\n    this.existTime = 0;\n    this.gravityWellSize = 500;\n    this.gravityConstant = 1000 * 0.5;\n    this.radius = 15\n\n    // this.id = options.id\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_red.wav\", 1);\n    this.playSound(this.spawnSound)\n\n    this.increasing = true\n    this.addLineSprite(new SingularitySprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    \n    this.lineSprite.throbbingScale = 1\n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    this.addCollider(\"GravityWell\", this, this.gravityWellSize, [\"Grunt\", \"Pinwheel\", \"Bullet\", \"Ship\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"Particle\", \"SingularityParticle\"],  [\"General\"])\n    // this.addCollider(\"GravityAbsorb\", this, this.radius, [\"Grunt\", \"Pinwheel\", \"Bullet\", \"Ship\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\"], [\"General\"])\n    // now it will move\n    this.addPhysicsComponent()\n    this.lineSprite.spawned = true\n    this.addChildGameObject(new SingularityParticles(this.gameEngine, this.transform))\n  }\n\n  onCollision(collider, type){\n    if (type === \"GravityWell\"){\n      this.influenceAcceleration(collider.gameObject)\n    }\n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n  \n\n  update(deltaTime) {\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition())) {\n      this.wallGraze()\n    }\n\n    this.throb(deltaTime)\n  }\n\n  throb(timeDelta) {\n    this.existTime += timeDelta;\n\n    let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let cycleSpeed = 0.025;\n    // increase scale until 1.2, decrease until 0.8\n\n    if (this.increasing) {\n      this.lineSprite.throbbingScale += cycleSpeed * cycleSpeedScale\n      if (this.lineSprite.throbbingScale > 1.2) {\n        this.increasing = !this.increasing\n      }\n    } else {\n      this.lineSprite.throbbingScale -= cycleSpeed * cycleSpeedScale\n      if (this.lineSprite.throbbingScale < 0.8) {\n        this.increasing = !this.increasing\n      }\n    }\n  }\n\n  influenceAcceleration(object) {\n    let pos = this.transform.absolutePosition()\n    let objectPos = object.transform.absolutePosition()\n    let dy = pos[1] - objectPos[1];\n    let dx = pos[0] - objectPos[0];\n    let unitVector = Util.dir([dx, dy]);\n    let r = Math.sqrt(dy * dy + dx * dx);\n    if (r > this.gravityWellSize * 7 / 8 || r < this.radius * 2){\n      object.transform.acc = [0,0];\n    } else {\n      let accContribution= [\n        unitVector[0] * this.gravityConstant / (r * r),\n        unitVector[1] * this.gravityConstant / (r * r)\n      ]\n      object.transform.acc[0] += accContribution[0];\n      object.transform.acc[1] += accContribution[1];\n    }\n  }\n}\n\nmodule.exports = Singularity;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass SingularitySprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.throbbingScale = 1\n    this.radius = 15;\n    this.spawned = false;\n  }\n\n  draw(ctx) {\n    let spawningScale = this.spawningScale\n    if (this.spawned) {\n      spawningScale = this.throbbingScale\n    }\n\n    ctx.strokeStyle = \"#F173BA\"\n\n    let r = 95;\n    let g = 45;\n    let b = 73;\n\n    ctx.save();\n    // ctx.translate(pos[0], pos[1]);\n\n    // ctx.strokeStyle = \"#4286f4\";\n    // ctx.lineWidth = 4;\n    let blurFactor = 0.5\n\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5;\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 6\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 4.5\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 3\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.restore();\n    // ctx.lineWidth = 2;\n    // drawSingularity(ctx, this.radius * spawningScale);\n  }\n\n  drawSingularity(ctx, radius) {\n    ctx.beginPath();\n    let pos = this.transform.absolutePosition()\n    ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\n    ctx.stroke();\n  }\n}\n\nmodule.exports = SingularitySprite","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst WeaverSprite = require(\"./weaver_sprite\")\n\nclass Weaver extends GameObject {\n  constructor(engine, pos, shipTransform) {\n    super(engine)\n    this.rotation_speed = 0.075;\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[0]\n    this.speed = 2;\n    this.shipTransform = shipTransform\n    this.weaverCloseHitBox = 35;\n    this.directionInfluenced = false;\n    this.influencers = [];\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_green.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new WeaverSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.exists = false;\n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, 3)\n    this.addCollider(\"BulletDodge\", this, this.weaverCloseHitBox, [\"Bullet\"], [\"General\"])\n    // now it will move\n    this.addPhysicsComponent()\n    this.exists = true;\n  }\n\n  onCollision(collider, type){\n    if (type === \"BulletDodge\") {\n      this.acceptBulletDirection(collider.gameObject.transform.pos)\n    }\n  }\n\n  influenceDirection() {\n    let directionVector = [0, 0]\n\n    this.influencers.forEach((influencer) => {\n      let dx = directionVector[0] + influencer[0];\n      let dy = directionVector[1] + influencer[1];\n      let newVector = [dx, dy]\n      directionVector = Util.dir(newVector);\n    })\n    let influencedDirection = Math.atan2(directionVector[1], directionVector[0]);\n    return influencedDirection\n  }\n\n  acceptBulletDirection(source) {\n    this.directionInfluenced = true;\n    let dy = this.transform.pos[1] - source[1];\n    let dx = this.transform.pos[0] - source[0];\n    let unitVector = Util.dir([dx, dy]);\n    this.influencers.push(unitVector)\n    // first \n  }\n\n  update(timeDelta){\n    if(this.exists){\n      let speed = 2\n      const rotationSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2)\n      \n      if (!this.directionInfluenced) {\n        this.chase(timeDelta)\n      } else {\n        let direction = this.influenceDirection();\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale\n      }\n  \n      this.directionInfluenced = false;\n  \n      if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition())) {\n        this.wallGraze()\n      }\n    }\n    \n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  chase(timeDelta) {\n    let speed = 2\n    let shipPos = this.shipTransform.pos;\n    let dy = shipPos[1] - this.transform.pos[1];\n    let dx = shipPos[0] - this.transform.pos[0];\n\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let direction = Math.atan2(dy, dx);\n\n    this.transform.pos[0] += speed * Math.cos(direction) * velocityScale\n    this.transform.pos[1] += speed * Math.sin(direction) * velocityScale\n  }\n\n}\n\nWeaver.BOX_SIZE = 10;\nWeaver.COLOR = \"#3cff0b\"\n\nmodule.exports = Weaver;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass WeaverSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n\n    let pos = this.transform.absolutePosition();\n    let angle = this.transform.absoluteAngle();\n    let spawningScale = this.spawningScale\n    let shipLength = 10 * 2.2 * spawningScale\n    let shipWidth = 10 * 2.2 * spawningScale\n    let s = shipWidth / 2;\n\n    let r = 24;\n    let g = 255;\n    let b = 4;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(angle);\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    this.drawWeaver(ctx, s)\n    ctx.lineWidth = 6\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n    this.drawWeaver(ctx, s)\n    ctx.lineWidth = 4.5;\n    this.drawWeaver(ctx, s)\n    ctx.lineWidth = 3;\n    this.drawWeaver(ctx, s)\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawWeaver(ctx, s)\n\n    ctx.restore();\n  }\n\n  drawWeaver(ctx, s) {\n\n    ctx.beginPath();\n    // ctx.strokeStyle = \"#3cff0b\";\n    ctx.lineWidth = 2;\n    ctx.moveTo(0, -s); //1\n    ctx.lineTo(s, 0); //2\n    ctx.lineTo(0, s); //3\n    ctx.lineTo(-s, 0); //4\n    ctx.lineTo(0, -s); //1\n    ctx.lineTo(-s / 2, -s / 2); //5\n    ctx.lineTo(s / 2, -s / 2); //6\n    ctx.lineTo(s / 2, s / 2); //7\n    ctx.lineTo(-s / 2, s / 2); //8\n    ctx.lineTo(-s / 2, -s / 2); //5\n    // ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = WeaverSprite","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartisian(angle, scale)\n//\n// \nconst ParticleSprite = require(\"./particle_sprite\")\n\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\n\nclass Particle extends GameObject{\n  constructor(engine, pos, initialSpeed, color) {\n    super(engine)\n\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n\n    this.color = color\n    this.movementAngle = Math.random() * Math.PI * 2;\n    this.transform.vel = Util.vectorCartisian(this.movementAngle, initialSpeed)\n    \n    this.explosionDeceleration = 0.1; // in the direction the particle is moving\n    this.transform.acc = [-this.explosionDeceleration * Math.cos(this.movementAngle), -this.explosionDeceleration * Math.sin(this.movementAngle)]\n\n    this.addLineSprite(new ParticleSprite(this.transform, this.color))\n    this.addPhysicsComponent()\n    this.addCollider(\"General\", this, 3)\n\n  }\n\n  rand(max, min, _int) {\n    var max = (max === 0 || max) ? max : 1,\n      min = min || 0,\n      gen = min + (max - min) * Math.random();\n\n    return (_int) ? Math.round(gen) : gen;\n  };\n\n  update(deltaTime){\n    this.lineSprite.rectLength -= 0.1;\n    this.lineSprite.color.a -= 0.01;\n    if (this.lineSprite.hue < 0.06 || this.lineSprite.rectLength < 0.25 || ((Math.abs(this.transform.vel[0]) + Math.abs(this.transform.vel[1])) < 0.15)) {\n      \n      this.remove();\n    }\n    // acc is influenced by singularities, then changed to usual acc\n    this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0])\n    this.transform.acc = [-this.explosionDeceleration * Math.cos(this.movementAngle), -this.explosionDeceleration * Math.sin(this.movementAngle)]\n  }\n\n}\n\nmodule.exports = Particle;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass ParticleSprite extends LineSprite {\n  constructor(transform, color) {\n    super(transform)\n    this.rectLength = 15;\n    this.rectWidth = 2;\n    this.color = color\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    let l = this.rectLength;\n    let w = this.rectWidth;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = this.color.evaluateColor();\n    ctx.lineWidth = w;\n\n    ctx.moveTo(0, 0); //1\n    ctx.lineTo(0, l); //2\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n}\n\nmodule.exports = ParticleSprite;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nconst ParticleSprite = require(\"../Particle/particle_sprite\")\n\nclass SingularityParticleSprite extends LineSprite {\n  constructor(transform, color) {\n    super(transform)\n    this.rectLength = 15;\n    this.rectWidth = 2;\n    this.color = color\n  }\n \n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    let l = this.rectLength;\n    let w = this.rectWidth;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = this.color.evaluateColor();\n    ctx.lineWidth = w;\n\n    ctx.moveTo(0, 0); //1\n    ctx.lineTo(0, l); //2\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n}\n\nmodule.exports = SingularityParticleSprite;","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartisian(angle, scale)\n//\n// \nconst SingularityParticleSprite = require(\"./singulairty_particle_sprite\")\n\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\nconst Particle = require(\"../Particle/particle\")\n\nclass SingularityParticle extends Particle {\n  constructor(engine, pos, vel, color) {\n    super(engine, pos, 0, color)\n\n    this.transform.vel[0] = vel[0]\n    this.transform.vel[1] = vel[1]\n\n    this.color = color;\n  }\n\n  update(deltaTime) {\n    this.lineSprite.rectLength -= 0.25;\n    this.lineSprite.color.a -= 0.01;\n    if (this.lineSprite.color.a < 0.06 || this.lineSprite.rectLength < 0.25) {\n      this.parentObject.currentParticleCount -= 1;\n      this.remove();\n    }\n    // acc is influenced by singularities, then changed to usual acc\n    this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0])\n    this.transform.acc = [0,0]\n  }\n\n}\n\nmodule.exports = SingularityParticle;","const Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass BulletWallExplosion extends GameObject{\n  constructor(engine, pos) {\n    super(engine)\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    let startingH = (this.gameEngine.gameScript.explosionColorWheel + 180 + Math.random() * 60) % 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n    this.particleNum = 20;\n    let bulletWallHit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 0.1)\n    this.playSound(bulletWallHit)\n    this.createParticles()\n  }\n\n  createParticles(){\n    for (var i = 0; i < this.particleNum; i++) {\n      const colorVarienceDelta = 30\n      const speed = 1 + Math.random() * 3\n      let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n      let color = this.currentColor.dup()\n      color.a = Math.random() * 0.35 + 0.6\n      color.h = (color.h + colorVarience) % 360\n      \n      this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n    }\n  }\n\n  update() {\n    \n    if (this.childObjects.length === 0) {\n      this.remove()\n    }\n  }\n}\n\nmodule.exports = BulletWallExplosion","const GameObject = require(\"../../game_engine/game_object\")\n\nclass EnemySpawn extends GameObject{\n  constructor(engine){\n    super(engine)\n    this.initialSpawningScale = 1.5;\n    // this.spawningScale = 1.5;\n    this.lifeTime = 1000;\n    this.existTime = 0;\n    // this.gameEngine.queueSound(this.parentObject.spawnSound)\n  }\n\n  update(timeDelta) {\n    this.existTime += timeDelta;\n    if (this.existTime >= this.lifeTime){\n      \n      this.parentObject.exist()\n      this.parentObject.lineSprite.spawningScale = 1;\n      this.remove()\n    }\n\n    let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let cycleSpeed = 0.1;\n    \n    if (this.parentObject.lineSprite.spawningScale < 0.7){\n      this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\n    } else {\n      this.parentObject.lineSprite.spawningScale -= cycleSpeed * cycleSpeedScale;\n    }\n  }\n}\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\nmodule.exports = EnemySpawn;","\nconst Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass ParticleExplosion extends GameObject{\n  constructor(engine, pos){\n    super(engine)\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    let startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60)% 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n    this.particleNum = 80;\n    let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n    this.playSound(explosionSound)\n    this.createExplosionParticles()\n  }\n\n  createExplosionParticles(){\n    for (var i = 0; i < this.particleNum; i++) {\n      const speed = Math.random() * 3 + 4\n\n      const colorVarienceDelta = 30\n      let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n      let color = this.currentColor.dup()\n      color.a = Math.random() * 0.35 + 0.6\n      color.h = (color.h + colorVarience) % 360\n\n      this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n    }\n  }\n\n  update(){\n    if (this.childObjects.length === 0){\n      this.remove()\n    }\n  }\n    // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = ParticleExplosion;","const GameObject = require(\"../../game_engine/game_object\")\nconst Util = require(\"../../game_engine/util\")\nconst SingularityParticle = require(\"./Singularity_Particle/singularity_particle\")\nconst Color = require(\"../../game_engine/color\")\n\nclass SingularityParticles extends GameObject {\n  constructor(engine, transform) {\n    super(engine)\n    this.transform = transform\n    let startingH = Math.random() * 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.frequencyParticleCreation = 10;\n    this.particleCreationTime = 0;\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n\n    this.particleNum = 80;\n    this.currentParticleCount = 0;\n    // let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n    this.createSingularityParticles()\n    \n  }\n\n  createSingularityParticles() {\n    \n    for (var i = 0; i < this.particleNum; i++) {\n      this.addSingularityParticle()\n      this.currentParticleCount++\n    }\n  }\n\n  addSingularityParticle(){\n    const L = 70\n    const length = 0\n    const baseSpeed = 3\n\n    const distanceVarienceDelta = 15\n    const colorVarienceDelta = 10\n    const angleVarienceDelta = Math.PI / 4\n    const speedVarienceDelta = 2\n\n    let distanceVarience = distanceVarienceDelta * Math.random() - distanceVarienceDelta / 2\n    let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n    let angleVarience = angleVarienceDelta * Math.random() - angleVarienceDelta / 2\n    let speedVarience = speedVarienceDelta * Math.random() - speedVarienceDelta / 2\n\n    let r = L + distanceVarience\n    let theta = Math.random() * 2 * Math.PI\n    let alpha = theta + Math.PI / 2 +  angleVarience\n    let speed = baseSpeed + speedVarience\n\n    let pos = [r * Math.cos(theta) + this.transform.pos[0], r * Math.sin(theta) + this.transform.pos[1]]\n    let vel = [speed * Math.cos(alpha) + this.transform.vel[0], speed * Math.sin(alpha) + this.transform.vel[1]]\n    let color = this.currentColor.dup()\n\n    color.a = Math.random() * 0.19 + 0.8\n    color.h = (color.h + colorVarience) % 360\n\n    this.addChildGameObject(new SingularityParticle(this.gameEngine, pos, vel, color));\n  }\n\n  changeCurrentColor(){\n    this.currentColor.h += 1 / 2\n    this.currentColor.h = this.currentColor.h % 360\n  }\n\n  update(timeDelta) {\n    this.particleCreationTime += timeDelta\n    if (this.particleCreationTime > this.frequencyParticleCreation){\n      this.particleCreationTime = 0\n      if (this.currentParticleCount < 60){\n        this.addSingularityParticle()\n      }\n    }\n    this.changeCurrentColor()\n  }\n  // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = SingularityParticles;","const GameObject = require(\"../../game_engine/game_object\");\nconst Util = require(\"../../game_engine/util\");\nconst Sound = require(\"../../game_engine/sound\");\n\nconst Bullet = require(\"../Bullet/bullet\");\nconst ShipSprite = require(\"./ship_sprite\")\n\nclass Ship extends GameObject {\n  constructor(engine, pos) { \n    super(engine);\n    this.transform.pos = pos\n    this.addPhysicsComponent()\n    this.addMousePosListener()\n    this.addLeftControlStickListener()\n    this.radius = 10\n    this.addCollider(\"General\", this, this.radius)\n    this.addCollider(\"ShipDeath\", this, this.radius, [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\"], [\"General\"])\n    this.addLineSprite(new ShipSprite(this.transform))\n    this.maxSpeed = 2.5;\n    this.mousePos = [0,0];\n    this.fireAngle = 0;\n    this.bulletSound = new Sound(\"GEOWars/sounds/Fire_normal.wav\", 0.2);\n    this.bulletTimeCheck = 0;\n    this.bulletInterval = 120;\n    this.controlsDirection = [0,0];\n    this.powerLevel = 1;\n    this.bulletNumber = 0;\n    this.speed\n    this.shipEngineAcceleration = 0.125;\n\n    this.keysPressed = []\n  }\n  \n  update(deltaTime){\n    this.bulletTimeCheck += deltaTime\n    if (this.bulletTimeCheck >= this.bulletInterval ) {\n      this.bulletNumber += 1\n      this.bulletTimeCheck = 0;\n      this.fireBullet();\n    } \n\n    // this.moveInControllerDirection(deltaTime)\n\n    if (this.isOutOfBounds()) {\n      this.wallGraze();\n    } else {\n      this.movementMechanics(deltaTime)\n    }\n    // if ship is out of x bounds, maintain y speed, keep x at edge value\n  }\n\n  // \n  calcControlsDirection(){\n    this.controlsDirection = [0,0]\n    this.keysPressed.forEach((key) => {\n      this.controlsDirection[0] += Ship.MOVES[key][0]\n      this.controlsDirection[1] += Ship.MOVES[key][1]\n    })\n  }\n\n  movementMechanics(deltaTime) {\n    // get dV\n    //    mV => max speed in the direction of the controller\n    //    Vo => current velocity\n    //    dV~ =  mV - Vo\n    // if dv~ > 0.2 (or something)\n    //    a = ma~ \n    let controlsDirection = this.calcControlsDirection()\n    let movementAngle = Math.atan2(this.controlsDirection[1], this.controlsDirection[0])\n    let Vo = this.transform.absoluteVelocity()\n    this.transform.angle = movementAngle\n    \n    let mV = []\n\n    if (this.controlsDirection[0] === 0 && this.controlsDirection[1] === 0){\n      mV = [0,0]\n    } else {\n      mV = [this.maxSpeed * Math.cos(movementAngle), this.maxSpeed * Math.sin(movementAngle)]\n    }\n\n    let dV = [mV[0] - Vo[0], mV[1] - Vo[1]]\n    let alpha = Math.atan2(dV[1], dV[0])\n\n    this.transform.acc[0] += this.shipEngineAcceleration * Math.cos(alpha)\n    this.transform.acc[1] += this.shipEngineAcceleration * Math.sin(alpha)\n    \n    \n  }\n\n  isOutOfBounds(){\n    return this.gameEngine.gameScript.isOutOfBounds(this.transform.pos, this.radius * 2)\n  }\n\n  updateMousePos(mousePos){\n    this.setFireAngle(mousePos)\n\n  }\n\n  updateRightControlStickInput(){\n\n  }\n\n  updateLeftControlStickInput(key, down = true) {\n    \n    // accelerates to V = [0,0] when not pressed\n    if (down) {\n      if(!this.keysPressed.includes(key)){\n        this.keysPressed.push(key)\n      }\n      \n      // this.controlsDirection[0] += unitVector[0]\n      // this.controlsDirection[1] += unitVector[1]\n    } else { \n       if (this.keysPressed.includes(key)) {\n         this.keysPressed.splice(this.keysPressed.indexOf(key), 1)\n       }\n      \n      // this.controlsDirection[0] -= unitVector[0]\n      // this.controlsDirection[1] -= initVector[1]\n    }\n  } \n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  onCollision(collider, type) {\n    if (type === \"ShipDeath\") {\n      // let hitObjectTransform = collider.gameObject.transform\n      // let pos = hitObjectTransform.absolutePosition()\n      // let vel = hitObjectTransform.absoluteVelocity()\n      // let explosion = new ParticleExplosion(this.gameEngine, pos, vel)\n      // collider.gameObject.remove()\n      console.log(\"DEAD\")\n    }\n  }\n\n  setFireAngle(mousePos) {\n    \n    if (mousePos === undefined){\n      mousePos = this.mousePos;\n    } else {\n      this.mousePos = mousePos\n    }\n    let dy = mousePos[1] - this.transform.pos[1];\n    let dx = mousePos[0] - this.transform.pos[0];\n    this.fireAngle =  Math.atan2(dy, dx)\n  }\n\n  fireBullet() {\n    \n    this.gameEngine.queueSound(this.bulletSound)\n    let shipvx = this.transform.vel[0];\n    let shipvy = this.transform.vel[1];\n\n    let relBulletVelX1 = Bullet.SPEED * Math.cos(this.fireAngle);\n    let relBulletVelY1 = Bullet.SPEED * Math.sin(this.fireAngle);\n\n    const bulletVel1 = [shipvx + relBulletVelX1, shipvy + relBulletVelY1];\n    this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel1, this.bulletNumber))\n\n    if (this.powerLevel === 2) {\n\n      let relBulletVelX2 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle + Math.PI / 32);\n      let relBulletVelY2 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle + Math.PI / 32);\n      let relBulletVelX3 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle - Math.PI / 32);\n      let relBulletVelY3 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle - Math.PI / 32);\n\n      const bulletVel2 = [shipvx + relBulletVelX2, shipvy + relBulletVelY2];\n      const bulletVel3 = [shipvx + relBulletVelX3, shipvy + relBulletVelY3];\n      // doesn't support parent transformations... yet\n      this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel2))\n      this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel3))\n    }\n  }\n\n\n  // implement threshold so it's not too sensitive\n\n  \n\n  relocate() {\n    // this.GameScript.die();\n    // this.transform.pos = this.game.randomPosition();\n    // this.vel = [0, 0];\n    // this.acc = [0, 0];\n  }\n}\n\nmodule.exports = Ship;\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nShip.MOVES = {\n  s: [0, 1],\n  a: [-1, 0],\n  w: [0, -1],\n  d: [1, 0],\n}","const LineSprite = require(\"../../game_engine/line_sprite\")\n\nclass ShipSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition()\n    let shipWidth = 10\n    let vel = this.transform.absoluteVelocity()\n    // let movementDirection = Math.atan2(vel[0], -vel[1])\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(this.transform.angle + Math.PI / 4);\n    ctx.translate(-shipWidth / 2, shipWidth / 2);\n\n    ctx.strokeStyle = \"#ffffff\";\n    let r = 255;\n    let g = 255;\n    let b = 255;\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n    ctx.lineWidth = 7.5 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n    this.drawShip(ctx, shipWidth)\n    ctx.lineWidth = 6 * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n    this.drawShip(ctx, shipWidth)\n    ctx.lineWidth = 4.5;\n    this.drawShip(ctx, shipWidth)\n    ctx.lineWidth = 3;\n    this.drawShip(ctx, shipWidth)\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawShip(ctx, shipWidth)\n\n    ctx.restore();\n  }\n\n  drawShip(ctx, shipWidth) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, -shipWidth);\n    ctx.lineTo(2 / 3 * shipWidth, -(1 + 1 / 6) * shipWidth); //1\n    ctx.lineTo(1 / 3 * shipWidth, -5 / 6 * shipWidth) // 2\n    ctx.lineTo(1 / 3 * shipWidth, -1 / 3 * shipWidth) // 2.5\n    ctx.lineTo(5 / 6 * shipWidth, -1 / 3 * shipWidth) // 3\n    ctx.lineTo((1 + 1 / 6) * shipWidth, -2 / 3 * shipWidth) // 4\n    ctx.lineTo(shipWidth, 0) // 5\n    ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = ShipSprite;","\nconst Ship = require(\"./game_objects/ship/ship\");\nconst BoxBox = require(\"./game_objects/enemies/BoxBox/boxbox\");\nconst Pinwheel = require(\"./game_objects/enemies/Pinwheel/pinwheel\");\nconst Arrow = require(\"./game_objects/enemies/Arrow/arrow\");\nconst Grunt = require(\"./game_objects/enemies/Grunt/grunt\");\nconst Weaver = require(\"./game_objects/enemies/Weaver/weaver\");\nconst Singularity = require(\"./game_objects/enemies/Singularity/singularity\");\n\nconst Util = require(\"./game_engine/util\");\nconst Sound = require(\"./game_engine/sound\")\n\nclass GameScript {\n  constructor(engine) {\n    this.theme = new Sound(\"GEOWars/sounds/Geometry_OST.mp3\", 1)\n    this.DIM_X = 1000;\n    this.DIM_Y = 600;\n    this.BG_COLOR = \"#000000\";\n    this.gameTime = 0;\n    this.engine = engine\n    this.arrowAdded = false\n    this.ship = this.createShip();\n    this.enemyCreatorList = this.createEnemyCreatorList()\n    // this.deathSound = new Audio(\"GEOWars/sounds/Enemy_explode.wav\")\n    // this.deathSound.volume = 0.5;\n    \n    this.intervalTiming = 1;\n    this.intervalTime = 0;\n    this.hugeSequenceTime = 0;\n    this.sequenceCount = 0;\n    this.lives = 3;\n    this.soundsToPlay = {}\n\n    this.spawnthing = false;\n    this.explosionColorWheel = 0;\n  }\n\n  update(deltaTime){\n    this.spawnSequence(deltaTime)\n    this.changeExplosionColor()\n  }\n\n  changeExplosionColor(){\n    this.explosionColorWheel += 1 / 2\n    this.explosionColorWheel = this.explosionColorWheel % 360\n  }\n\n  onPause(){\n\n  }\n\n  onUnPause(){\n\n  }\n\n  randomArrowDirection() {\n    let angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2]\n    return angles[Math.floor(Math.random() * angles.length) % angles.length]\n  }\n\n  createEnemyCreatorList() {\n    let engine = this.engine \n    return {\n      BoxBox:      (pos)        => (new BoxBox(engine, pos)),\n      Pinwheel:    (pos)        => (new Pinwheel(engine, pos)),\n      Arrow:       (pos, angle) => (new Arrow(engine, pos, angle)),\n      Grunt:       (pos)        => (new Grunt(engine, pos, this.ship.transform)),\n      Weaver:      (pos)        => (new Weaver(engine, pos, this.ship.transform)),\n      Singularity: (pos)        => (new Singularity(engine, pos))\n    };\n  }\n\n  randomSpawnEnemy(enemy) {\n    let pos = this.randomPosition();\n    let enemyCreators = Object.values(this.enemyCreatorList)\n    enemyCreators[Math.floor(Math.random() * enemyCreators.length) % enemyCreators.length](pos);\n    // this.enemyCreatorList[\"BoxBox\"](pos)\n  }\n\n  // spawnEnemies(spawnList) {\n  //   if (this.enemies.length < 50) {\n  //     spawnList.forEach((enemy) => {\n  //       let spawn = new EnemySpawn(enemy, this)\n  //       this.add(spawn)\n  //     })\n  //   }\n  // }\n\n  randomPosition() {\n    return [\n      this.DIM_X * Math.random(),\n      this.DIM_Y * Math.random(),\n      // 500,300\n    ];\n  }\n\n  spawnSequence(delta) {\n    this.intervalTime += delta;\n    \n    // if (this.intervalTime > 2000) {\n    //   this.randomSpawnEnemy();\n    //   this.intervalTime = 0\n    //   if (this.firstArrowAdded) {\n    //     this.arrowAdded = true\n    //   }\n    //   this.firstArrowAdded = true \n    // }\n\n    this.gameTime += delta;\n    if (this.intervalTime > (500 * this.intervalTiming) && this.sequenceCount < 10) {\n      this.intervalTime = 0;\n      this.randomSpawnEnemy();\n      this.sequenceCount += 1\n\n    } \n    else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount === 10 && this.hugeSequenceTime % 2 === 0) {\n      this.intervalTime = 0\n      this.sequenceCount += 1\n      let enemies_to_spawn = []\n      let randomPos = this.randomPosition();\n      for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n          enemies_to_spawn.push(\n            this.enemyCreatorList[\"BoxBox\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n          )\n        }\n      }\n\n    } else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount === 10 && this.hugeSequenceTime % 2 === 1) {\n      this.intervalTime = 0\n      this.sequenceCount += 1\n      let enemies_to_spawn = []\n      let randomPos = this.randomPosition();\n      for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n          this.enemyCreatorList[\"Weaver\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n        }\n      }\n\n    } else if (this.intervalTime > (5000 * this.intervalTiming) && this.sequenceCount === 11) {\n      this.intervalTime = 0;\n      this.sequenceCount += 1;\n    } else if (this.intervalTime > 250 && this.sequenceCount < (11 + 15) && (this.sequenceCount > 11) && this.hugeSequenceTime % 2 === 0) {\n      this.ship.powerLevel = 2\n      this.intervalTime = 0;\n      this.sequenceCount += 1;\n\n      let enemies_to_spawn = [];\n      let fourCorners = [\n        [40, 40],\n        [GameScript.DIM_X - 40, 40],\n        [40, GameScript.DIM_Y - 40],\n        [GameScript.DIM_X - 40, GameScript.DIM_Y - 40]\n      ]\n      fourCorners.forEach((corner) => {\n        this.enemyCreatorList[\"Grunt\"](corner)\n      })\n\n    } else if (this.intervalTime > 250 && this.sequenceCount < (11 + 15) && (this.sequenceCount > 11) && this.hugeSequenceTime % 2 === 1) {\n      this.intervalTime = 0;\n      this.sequenceCount += 14;\n\n      let enemies_to_spawn = [];\n      let arrowWallPositions = []\n      let arrowDirection = Math.PI * 3 / 2 + Math.PI\n      for (let i = 40; i < GameScript.DIM_X; i += 40) {\n        arrowWallPositions.push([i, 50])\n      }\n\n      arrowWallPositions.forEach((position) => {\n        this.enemyCreatorList[\"Arrow\"](position, arrowDirection)\n      })\n\n    } else if (this.sequenceCount >= 26) {\n      this.sequenceCount = 0;\n      if (!(this.intervalTiming < 0.5)) {\n        this.intervalTiming *= 0.9;\n      }\n      this.hugeSequenceTime += 1;\n    }\n\n\n\n\n\n    // if (this.gameTime % 2000 === 0){\n    //   this.spawned = false\n    // }\n  }\n\n  createShip() {\n    return new Ship(this.engine, [500, 500])\n  }\n\n  isOutOfBounds(pos) {\n    return (pos[0] < 0) || (pos[1] < 0) ||\n      (pos[0] > GameScript.DIM_X) || (pos[1] > GameScript.DIM_Y);\n  }\n\n  updateShipFireAngle() {\n    this.ships[0].setFireAngle()\n  }\n\n  // bounce(pos){\n  //   return [\n  //     Util.bounce(pos[0], GameScript.DIM_X), Util.bounce(pos[1], GameScript.DIM_Y)\n  //   ];\n  // }\n\n  bounce(transform, radius = 0) {\n    let max = [this.DIM_X - radius, this.DIM_Y - radius]\n    let pos = transform.absolutePosition()\n    if (pos[0] <= radius || pos[0] >= max[0]) {\n      transform.vel[0] = -transform.vel[0];\n    }\n    if (pos[1] <= radius || pos[1] >= max[1]) {\n      transform.vel[1] = -transform.vel[1];\n    }\n  }\n\n  wallGraze(transform, radius = 0){\n    let max = [this.DIM_X - radius, this.DIM_Y - radius]\n    let pos = transform.absolutePosition()\n    let vel = transform.absoluteVelocity()\n\n    // X bounds, left right\n    if (pos[0] <= radius && vel[0] < 0){\n      transform.vel[0] = 0.1;\n    } else if (pos[0] >= max[0] && vel[0] > 0){\n      transform.vel[0] = -0.1;\n    }\n\n    // Y bounds, top bottom\n    if(pos[1] <= radius && vel[1] < 0) {\n      transform.vel[1] = 0.1\n    } else if (pos[1] >= max[1] && vel[1] > 0){\n      transform.vel[1] = -0.1\n    }\n\n  }\n\n  redirect(transform) {\n    let max = [this.DIM_X, this.DIM_Y]\n    let pos = transform.absolutePosition()\n    \n    if (pos[0] <= 0 || pos[0] >= max[0]) {\n      if (pos[0] <= 0) {\n        pos[0] = 1\n\n        \n      }\n      if (pos[0] >= max[0]) {\n        pos[0] = max[0] - 1\n\n      }\n    }\n    if (pos[1] <= 0 || pos[1] >= max[1]) {\n      if (pos[1] <= 0) {\n        pos[1] = 1\n\n      }\n      if (pos[1] >= max[1]) {\n        pos[1] = max[1] - 1\n\n      }\n    }\n\n    transform.vel[0] = -transform.vel[0];\n    transform.vel[1] = -transform.vel[1];\n  }\n\n}\n\nGameScript.BG_COLOR = \"#000000\";\n\nGameScript.DIM_X = 1000;\nGameScript.DIM_Y = 600;\n// GameScript.FPS = 32;\n// GameScript.NUM_BOXES = 10;\n// GameScript.NUM_PINWHEELS = 0;\n// GameScript.NUM_ARROWS = 0;\n// GameScript.NUM_GRUNTS = 0;\n// GameScript.NUM_WEAVERS = 0;\n// GameScript.NUM_SINGULARITIES = 1;\nmodule.exports = GameScript;\n\nGameScript.Spawn1 = {\n  BoxBox: 50,\n}\n\nGameScript.spawnListList = [\n  GameScript.Spawn1\n]","\n\nclass GameView {\n  constructor(engine, ctx, canvasEl) {\n    this.ctx = ctx;\n    this.engine = engine;\n    // this.ship = this.game.addShip(); belongs in game script\n    this.canvasEl = canvasEl;\n    this.initialUnmute = true;\n    this.gameStarted = false;\n    this.modelClosed = false;\n    this.bindKeyboardKeys = this.bindKeyboardKeys.bind(this)\n    this.animate = this.animate.bind(this)\n  }\n\n  bindKeyboardKeys(){\n    window.addEventListener('keydown', this.doKeyEvent(true), true);\n    window.addEventListener('keyup', this.doKeyEvent(false), true);\n  }\n\n  updateMovementDirection(move, down){\n    this.engine.gameScript.ship.updateLeftControlStickInput(move, down);\n  }\n\n  /*\n    if true, change movement direction to the direction\n    if false, remove movement direction if it's the \n    same as the current movement direction\n  */\n\n  doKeyEvent(down) {\n    return (e) => {\n      if (e.key === \"m\" && this.initialUnmute) {\n        this.initialUnmute = false\n        this.engine.gameScript.theme.play()\n      }\n\n      if(e.key === \"m\" && down){\n        this.engine.toggleMute()\n        if (this.engine.muted){\n          this.engine.gameScript.theme.mute()\n        } else{\n          this.engine.gameScript.theme.unmute()\n        }\n        \n      }\n\n      let unitVector = GameView.MOVES[e.key]\n      if (unitVector) {\n        this.updateMovementDirection(e.key, down)\n      }\n    }\n  }\n\n  bindKeyHandlers() {\n    const engine = this.engine\n    // Object.keys(GameView.MOVES).forEach((k) => {\n    //   const move = GameView.MOVES[k];\n    //   key(k, () => {\n    //     this.engine.gameScript.ship.updateLeftControlStickInput(move);\n    //   });\n    // });\n\n    // key(\"m\", () => {\n    //   engine.muted = !engine.muted;\n    //   if (engine.muted) {\n    //     this.theme.pause();\n    //   } else {\n    //     this.theme.play();\n    //   }\n    // })\n\n    window.addEventListener('mousemove', (e) => {\n      const x = {x: e.layerX};\n      const y = {y: e.layerY};\n      const mousePos = [e.layerX, e.layerY];\n      this.engine.updateMousePos(mousePos)\n      // ship.setFireAngle(mousePos); add to game script event listener thing\n    });\n\n    function preventDefault(e) {\n      e = e || window.event;\n      if (e.preventDefault)\n        e.preventDefault();\n      e.returnValue = false;\n    }\n\n\n    function disableScroll() {\n      if (window.addEventListener) // older FF\n        window.addEventListener('DOMMouseScroll', preventDefault, false);\n      window.onwheel = preventDefault; // modern standard\n      window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n      window.ontouchmove = preventDefault; // mobile\n      // document.onkeydown = preventDefaultForScrollKeys;\n    }\n\n\n    if (window.addEventListener) // older FF\n      window.addEventListener('DOMMouseScroll', preventDefault, false);\n    window.onwheel = preventDefault; // modern standard\n    window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n    window.ontouchmove = preventDefault; // mobile\n   \n  }\n\n  start() {\n    this.lastTime = 0;\n    this.bindKeyHandlers();\n\n     // Get the modal\n     var modal = document.getElementById('myModal');\n\n     // Get the button that opens the modal\n     // var btn = document.getElementById(\"myBtn\");\n\n     // Get the <span> element that closes the modal\n     var xclose = document.getElementsByClassName(\"close\")[0];\n\n\n     // When the user clicks on <span> (x), close the modal\n     xclose.onclick = (e) => {\n       e.stopPropagation()\n       modal.style.display = \"none\";\n       this.modelClosed = true\n     }\n\n     // When the user clicks anywhere outside of the modal, close it\n    //  window.addEventListener('click', (e) => {\n     window.onclick = (event) => {\n       if (this.modelClosed && !this.gameStarted) {\n         this.gameStarted = true\n         this.bindKeyboardKeys()\n         requestAnimationFrame(this.animate);\n       }\n       if (event.target == modal) {\n         this.modelClosed = true\n         modal.style.display = \"none\";\n       }\n     }\n  }\n  \n  animate(time) {\n    const timeDelta = time - this.lastTime;\n    this.engine.tick(timeDelta, this.ctx);\n    this.lastTime = time;\n    // every call to animate requests causes another call to animate\n    requestAnimationFrame(this.animate.bind(this));\n  }\n}\n\nconst KEYMAP = {\n  87: \"W\",\n  82: \"R\",\n  90: \"Z\",\n  88: \"X\",\n  67: \"C\",\n  70: \"F\",\n  83: \"S\",\n  69: \"E\",\n  65: \"D\",\n  68: \"A\",\n}\n\nGameView.MOVES = {\n  s: [0,1],\n  a: [-1,0],\n  w: [0,-1],\n  d: [1,0],\n}\n\nmodule.exports = GameView;\n"],"sourceRoot":""}